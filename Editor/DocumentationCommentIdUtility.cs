#nullable enable
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using UnityEngine.Pool;

namespace Dcid
{
    public static class DocumentationCommentIdUtility
    {
        internal static ObjectPool<StringBuilder> StringBuilderPool { get; } =
            new(() => new StringBuilder(), x => x.Clear());

        public static IEnumerable<AssemblyDocumentationCommentIdData> GetDocumentationCommentIdData(
            IEnumerable<Assembly> assemblies)
        {
            var refs = assemblies
                .Where(x => !x.IsDynamic && !string.IsNullOrEmpty(x.Location))
                .Select(x => (asm: x, metadata: MetadataReference.CreateFromFile(x.Location)))
                .ToDictionary(x => x.asm.GetName().Name, x => x);
            var compilation = CSharpCompilation
                .Create("tmp-compilation", references: refs.Values.Select(x => x.metadata));
            return compilation.Assembly.Modules
                .SelectMany(x => x.ReferencedAssemblySymbols)
                .Distinct<IAssemblySymbol>(SymbolEqualityComparer.Default)
                .Select(x => GetAssemblyDocumentationCommentIdData(x, refs.GetValueOrDefault(x.Name)))
                .Where(x => x != null)!;
        }

        private static AssemblyDocumentationCommentIdData? GetAssemblyDocumentationCommentIdData(
            IAssemblySymbol asmSymbol, (Assembly? asm, PortableExecutableReference? metadata) refData)
        {
            if (refData.asm == null || refData.metadata == null) return null;
            var assemblyData = new AssemblyDocumentationCommentIdData
                { assemblyData = ToDocumentationCommentIdData(asmSymbol, DefinitionType.Assembly) };
            var classData = refData.asm.GetTypes()
                .Where(x => x.IsPublic)
                .Select(x => x.FullName)
                .Select(typeName => GetClassDocumentationCommentIdData(typeName, asmSymbol))
                .Where(x => x != null);
            foreach (var d in classData) assemblyData.classes.Add(d!);
            return assemblyData;
        }

        private static ClassDocumentationCommentIdData? GetClassDocumentationCommentIdData(string? typeName,
            IAssemblySymbol asm)
        {
            if (typeName == null) return null;
            var typeInfo = asm.GetTypeByMetadataName(typeName);
            if (typeInfo == null) return null;
            var data = new ClassDocumentationCommentIdData
                { classData = ToDocumentationCommentIdData(typeInfo, DefinitionType.Class) };
            foreach (var member in typeInfo.GetMembers()) AddMemberData(member, data);
            return data;
        }

        private static void AddMemberData(ISymbol member, ClassDocumentationCommentIdData data)
        {
            switch (member)
            {
                case IMethodSymbol:
                    data.methodDataList.Add(ToDocumentationCommentIdData(member, DefinitionType.Method));
                    break;
                case IPropertySymbol:
                    data.propertyDataList.Add(ToDocumentationCommentIdData(member, DefinitionType.Property));
                    break;
                case IFieldSymbol:
                    data.fieldDataList.Add(ToDocumentationCommentIdData(member, DefinitionType.Field));
                    break;
                default:
                    data.otherDataList.Add(ToDocumentationCommentIdData(member, DefinitionType.Other));
                    break;
            }
        }

        private static DocumentationCommentIdData ToDocumentationCommentIdData(
            ISymbol member, DefinitionType type) => new()
        {
            type = type,
            isAutoGenerated = IsAutGenerated(member),
            minimallyQualifiedName = member.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat),
            fullQualifiedName = member.ToDisplayString(FullyQualifiedFormat),
            documentationCommentId = member.GetDocumentationCommentId(),
            documentationComment = member.GetDocumentationCommentXml()
        };

        private static bool IsAutGenerated(ISymbol symbol) => symbol switch
        {
            IFieldSymbol fieldSymbol => IsAutGeneratedField(fieldSymbol),
            ITypeSymbol methodSymbol => IsAutGeneratedType(methodSymbol),
            _ => false
        };

        private static bool IsAutGeneratedField(IFieldSymbol? fieldSymbol)
        {
            if (fieldSymbol == null) return false;
            return fieldSymbol.Name.StartsWith("<") && fieldSymbol.Name.EndsWith(">k__BackingField");
        }

        private static bool IsAutGeneratedType(ITypeSymbol? methodSymbol)
        {
            return methodSymbol != null && methodSymbol.Name.StartsWith("<>c");
        }

        /// <see cref="SymbolDisplayFormat.FullyQualifiedFormat"/>
        private static SymbolDisplayFormat FullyQualifiedFormat { get; } = new(
            globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle
                .Omitted, // ここだけSymbolDisplayFormat.FullyQualifiedFormatと違う
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            miscellaneousOptions:
            SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |
            SymbolDisplayMiscellaneousOptions.UseSpecialTypes);
    }
}